# 数据模型

<cite>
**本文档引用的文件**
- [serverV2.py](file://serverV2.py)
- [config.json](file://config.json)
</cite>

## 目录
1. [章节JSON模型](#章节json模型)
2. [角色音色映射模型](#角色音色映射模型)
3. [文本替换规则模型](#文本替换规则模型)
4. [全局配置模型](#全局配置模型)
5. [数据验证与序列化最佳实践](#数据验证与序列化最佳实践)

## 章节JSON模型

本模型定义了由LLM分析生成的有声书章节数据结构，用于驱动后续的TTS（文本转语音）流程。该模型是一个JSON数组，数组中的每个对象代表一个对话或旁白片段。

**JSON Schema 定义**

```json
{
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "speaker": { "type": "string" },
      "content": { "type": "string" },
      "tone": { "type": "string" },
      "intensity": { "type": "integer", "minimum": 1, "maximum": 10 },
      "delay": { "type": "integer", "minimum": 0 }
    },
    "required": ["speaker", "content", "tone", "intensity", "delay"]
  }
}
```

**字段说明**

- **`speaker` (说话者)**: 字符串类型，表示说话者的姓名。对于旁白，该字段值为“旁白”；对于角色对话，则为具体的角色名称。系统会通过角色名归一化逻辑，确保同一角色在不同章节中使用一致的名称。
- **`content` (文本内容)**: 字符串类型，表示该片段的原始文本内容。系统会自动清理仅包含标点符号的内容，并确保长段落被合理拆分。
- **`tone` (语气)**: 字符串类型，描述说话时的语气或情绪，例如“正常”、“愤怒”、“开心”、“伤心”、“低声念叨”等。
- **`intensity` (情感强度)**: 整数类型，范围为1-10，表示语气的强烈程度。数值越大，情感越强烈。
- **`delay` (延迟毫秒)**: 整数类型，表示与上一句话之间的停顿时间（以毫秒为单位）。根据内容长度和对话节奏，该值通常在100至1500毫秒之间。

**生成逻辑**

该模型的数据由LLM（大语言模型）根据`PROMPT_TEMPLATE`提示词模板生成。`PROMPT_TEMPLATE`位于`serverV2.py`文件中，它严格规定了输出格式和内容要求。当处理一个章节时，系统会调用`generate_chapter_json`函数，该函数会根据`config.json`中的LLM配置（如`gemini`或`aliyun`）向相应的API发送请求。LLM的响应必须是且仅是一个符合上述规范的JSON数组，不包含任何额外的解释性文字。

**样本数据示例**

```json
[
  {
    "speaker": "旁白",
    "content": "夜色深沉，月光洒在古老的庭院里。",
    "tone": "正常",
    "intensity": 5,
    "delay": 500
  },
  {
    "speaker": "张三丰",
    "content": "徒儿，你可知道何为武学的至高境界？",
    "tone": "慈祥",
    "intensity": 6,
    "delay": 300
  },
  {
    "speaker": "张无忌",
    "content": "弟子愚钝，还请师父指点。",
    "tone": "恭敬",
    "intensity": 7,
    "delay": 800
  }
]
```

**业务流程中的作用**

此模型是整个有声书生成流程的核心。前端界面会加载此JSON数据，供用户进行编辑和调整。在TTS阶段，系统会遍历此数组，为每一项调用TTS服务，生成对应的音频片段。

**Section sources**
- [serverV2.py](file://serverV2.py#L153-L185)
- [serverV2.py](file://serverV2.py#L561-L592)

## 角色音色映射模型

本模型定义了角色与音色之间的映射关系，用于在TTS过程中为不同角色分配不同的声音。

**JSON Schema 定义**

```json
{
  "type": "object",
  "additionalProperties": { "type": "string" }
}
```

**字段说明**

- **`键 (Key)`**: 字符串类型，表示角色的名称。
- **`值 (Value)`**: 字符串类型，表示分配给该角色的音色名称。音色文件存储在`wav`目录下，每个音色文件夹包含一个参考音频（`1.wav`）和一段参考文本（`1.txt`）。

**生成逻辑**

该模型的数据由用户在前端界面中手动配置。用户可以从音色库中选择一个音色，并将其分配给特定的角色。当用户保存配置时，前端会调用`/api/update_config`接口，将此映射关系保存为`character_timbres.json`文件。当用户加载一个小说项目时，系统会通过`/api/get_config`接口获取此文件。

**样本数据示例**

```json
{
  "张三丰": "老者-沉稳",
  "张无忌": "青年-清朗",
  "赵敏": "少女-灵动"
}
```

**业务流程中的作用**

在拼接音频（`/api/splice_audio`）时，系统会读取此映射关系。对于章节JSON中的每一个`speaker`，系统会查找其对应的`timbre`，然后根据`{index:04d}-{speaker}-{timbre}.wav`的命名规则，找到对应的音频文件，并按顺序拼接成最终的有声书。

**Section sources**
- [serverV2.py](file://serverV2.py#L1708-L1727)
- [serverV2.py](file://serverV2.py#L1886-L1913)

## 文本替换规则模型

本模型定义了一组文本替换规则，用于在TTS生成前对文本内容进行预处理，以解决特定词汇的发音问题。

**JSON Schema 定义**

```json
{
  "type": "object",
  "properties": {
    "rules": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "original_word": { "type": "string" },
          "replacement_word": { "type": "string" },
          "description": { "type": "string" }
        },
        "required": ["original_word", "replacement_word"]
      }
    }
  },
  "required": ["rules"]
}
```

**字段说明**

- **`rules`**: 数组类型，包含所有替换规则。
  - **`original_word` (原词)**: 字符串类型，表示需要被替换的原始文本。
  - **`replacement_word` (替换词)**: 字符串类型，表示用来替换原词的文本。
  - **`description` (描述)**: 字符串类型，可选字段，用于记录该规则的用途或说明。

**生成逻辑**

该模型的数据由用户在前端的“替换词典”界面中手动添加和管理。当用户添加或删除规则并点击保存时，前端会调用`/api/novel/{novel_name}/replace_dict`接口。后端会验证规则的完整性（`original_word`和`replacement_word`不能为空），然后将规则列表保存为小说项目目录下的`replace_dict.json`文件。

**应用逻辑**

在调用TTS服务之前，系统会调用`apply_replacement_rules`函数。该函数会加载`replace_dict.json`中的规则，并按照`original_word`的长度从长到短排序，以避免短词影响长词的替换。然后，它会遍历所有规则，使用正则表达式对TTS文本进行替换。

**样本数据示例**

```json
{
  "rules": [
    {
      "original_word": "行长",
      "replacement_word": "hang长",
      "description": "避免将'行长'读成'hang长'"
    },
    {
      "original_word": "银行",
      "replacement_word": "yin行",
      "description": "确保'行'字读作'行'"
    }
  ]
}
```

**业务流程中的作用**

此模型确保了TTS生成的语音更加准确和自然。例如，可以将多音字“行”替换为带有拼音的“hang”或“xing”，以强制TTS引擎使用正确的发音。

**Section sources**
- [serverV2.py](file://serverV2.py#L1959-L1997)
- [serverV2.py](file://serverV2.py#L521-L559)

## 全局配置模型

本模型定义了系统的全局配置，包括LLM、TTS、音频导出等设置。

**JSON Schema 定义**

```json
{
  "type": "object",
  "properties": {
    "general": {
      "type": "object",
      "properties": {
        "default_model": { "type": "string" },
        "proxy": {
          "type": "object",
          "properties": {
            "enabled": { "type": "boolean" },
            "protocol": { "type": "string" },
            "address": { "type": "string" },
            "port": { "type": "string" }
          },
          "required": ["enabled", "protocol", "address", "port"]
        },
        "default_tts_model": { "type": "string" }
      },
      "required": ["default_model", "proxy", "default_tts_model"]
    },
    "audio_export": {
      "type": "object",
      "properties": {
        "format": { "type": "string", "enum": ["mp3", "wav", "m4a", "ogg"] },
        "quality": { "type": "string" }
      },
      "required": ["format", "quality"]
    },
    "tts_models": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "display_name": { "type": "string" },
          "endpoint": { "type": "string", "format": "uri" }
        },
        "required": ["display_name", "endpoint"]
      }
    },
    "models": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "display_name": { "type": "string" },
          "model_name": { "type": "string" },
          "api_key": { "type": "string" },
          "max_chars": { "type": "integer" },
          "use_proxy": { "type": "boolean" }
        },
        "required": ["display_name", "model_name", "max_chars", "use_proxy"]
      }
    },
    "elevenlabs": {
      "type": "object",
      "properties": {
        "api_key": { "type": "string" }
      },
      "required": ["api_key"]
    }
  },
  "required": ["general", "audio_export", "tts_models", "models"]
}
```

**字段说明**

- **`general`**: 通用配置。
  - `default_model`: 默认使用的LLM模型ID（如`gemini`）。
  - `proxy`: 代理配置，用于访问需要代理的API。
  - `default_tts_model`: 默认使用的TTS模型ID（如`cosyvoice_v2`）。
- **`audio_export`**: 音频导出配置。
  - `format`: 最终音频文件的格式（如`mp3`）。
  - `quality`: 音频质量（如`256k`）。
- **`tts_models`**: TTS模型配置，定义了可用的TTS服务。
  - `display_name`: 模型的显示名称。
  - `endpoint`: TTS服务的API端点URL。
- **`models`**: LLM模型配置，定义了可用的LLM服务。
  - `display_name`: 模型的显示名称。
  - `model_name`: LLM服务的实际模型名称。
  - `api_key`: 访问该LLM服务所需的API密钥。
  - `max_chars`: 单次请求允许的最大字符数。
  - `use_proxy`: 是否为此模型启用代理。
- **`elevenlabs`**: Speech-to-Text服务的API密钥。

**生成逻辑**

该模型的数据存储在项目根目录下的`config.json`文件中。系统启动时会调用`initialize_llm_config()`函数，如果文件不存在，则会创建一个包含默认配置的文件。用户可以在前端界面中修改这些配置，并通过`/api/update_llm_config`接口进行保存。

**样本数据示例**

```json
{
  "general": {
    "default_model": "gemini",
    "proxy": {
      "enabled": true,
      "protocol": "socks5h",
      "address": "127.0.0.1",
      "port": "1080"
    },
    "default_tts_model": "cosyvoice_v2"
  },
  "audio_export": {
    "format": "mp3",
    "quality": "256k"
  },
  "tts_models": {
    "cosyvoice_v2": {
      "display_name": "CosyVoice2",
      "endpoint": "http://127.0.0.1:5010/api/tts"
    }
  },
  "models": {
    "gemini": {
      "display_name": "Gemini",
      "model_name": "gemini-2.5-flash",
      "api_key": "your_api_key_here",
      "max_chars": 8000,
      "use_proxy": true
    }
  },
  "elevenlabs": {
    "api_key": ""
  }
}
```

**业务流程中的作用**

此模型是系统的“大脑”，为所有核心功能提供配置信息。LLM和TTS服务的调用都依赖于此配置。音频导出设置决定了最终成品的格式和质量。

**Section sources**
- [config.json](file://config.json)
- [serverV2.py](file://serverV2.py#L195-L245)

## 数据验证与序列化最佳实践

为确保数据的完整性和系统的稳定性，开发者在处理这些数据模型时应遵循以下最佳实践：

1.  **输入验证**: 在接收任何用户输入或API请求时，必须进行严格的验证。例如，在`UpdateReplaceDictRequest`模型中，已使用Pydantic确保`original_word`和`replacement_word`不为空。对于自定义的JSON数据，应使用`json.loads()`并捕获`JSONDecodeError`异常。
2.  **文件路径安全**: 在读写文件时，必须进行路径安全检查，防止目录遍历攻击。例如，在`delete_novel`和`get_novel_content`函数中，使用`os.path.abspath()`和`startswith()`来验证文件路径是否在允许的目录内。
3.  **序列化与反序列化**: 使用`json.dump()`和`json.load()`进行数据的序列化和反序列化。在写入文件时，建议使用`ensure_ascii=False`和`indent=4`以保证中文字符的正确显示和文件的可读性。
4.  **错误处理**: 所有文件I/O操作和网络请求都应包含在`try-except`块中，以优雅地处理可能发生的异常（如`FileNotFoundError`, `PermissionError`, `requests.exceptions.RequestException`），并向用户提供有意义的错误信息。
5.  **数据一致性**: 在修改数据后，应及时保存到文件系统。例如，在合并角色或更新配置后，应立即调用`json.dump()`将更新后的数据写回`character_timbres.json`或`replace_dict.json`文件。