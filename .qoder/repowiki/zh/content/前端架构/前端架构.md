# 前端架构

<cite>
**本文档引用的文件**   
- [index.html](file://index.html)
- [style.css](file://style.css)
- [config.json](file://config.json)
</cite>

## 目录
1. [项目结构](#项目结构)
2. [UI布局结构](#ui布局结构)
3. [应用状态管理](#应用状态管理)
4. [事件监听与用户交互](#事件监听与用户交互)
5. [前端API客户端实现](#前端api客户端实现)
6. [UI组件交互逻辑](#ui组件交互逻辑)
7. [样式组织与设计](#样式组织与设计)
8. [开发调试技巧](#开发调试技巧)

## 项目结构
项目包含以下核心文件：
- `index.html`：前端主页面，定义了UI布局和结构。
- `style.css`：样式表文件，定义了全局样式、响应式设计和组件样式。
- `config.json`：配置文件，包含默认模型、音频导出设置和TTS模型配置。
- `serverV2.py`：后端服务器脚本，提供RESTful API接口。
- `启动ServerV2.bat`：Windows批处理文件，用于启动后端服务器。

**Section sources**
- [index.html](file://index.html)
- [style.css](file://style.css)
- [config.json](file://config.json)

## UI布局结构
前端UI采用四列工作区布局，通过`spa-layout`类定义网格模板。各列功能如下：

### 小说管理面板
位于第一列，包含小说上传、选择和章节列表。用户可通过上传按钮添加新小说，或从下拉菜单中选择现有项目。章节列表支持多选、全选、全不选和过滤功能，便于批量操作。

### 章节处理区域
与小说管理面板集成在同一列，提供“处理文本”按钮，用于触发章节内容的AI处理流程。处理完成后，章节状态会在列表中更新。

### 角色管理弹窗
通过“角色名管理”按钮打开，允许用户搜索、合并角色名。该功能有助于统一不同章节中的角色名称变体，确保音色配置的一致性。

### 音色配置表格
位于第二列，显示当前选中章节中的所有角色及其音色分配。角色按是否已分配音色排序，未分配的角色以红色边框高亮。用户可点击“分配”按钮将音色分配给角色。

### 音色库
位于第三列，展示所有可用音色，支持按分类过滤。每个音色条目包含“分配”、“试听”按钮和“已分配角色”弹出菜单，方便用户管理和预览。

### 内容编辑器
位于第四列，是核心编辑区域。当用户选中一个已处理的章节时，编辑器会加载其内容并以表格形式展示。表格包含角色、音色、内容、TTS模型和操作按钮。

### 语音生成控制按钮
位于页面顶部的全局操作栏，包含“处理文本”、“生成声音”和“下载声音”按钮。这些按钮的状态根据用户选择的章节动态更新，确保操作的上下文相关性。

### 系统设置模态框
通过齿轮图标按钮打开，提供多标签页的全局配置。包括通用设置、LLM模型配置、TTS模型配置和音频导出设置，允许用户自定义应用行为。

**Section sources**
- [index.html](file://index.html#L399-L525)

## 应用状态管理
JavaScript通过全局`state`对象集中管理应用状态，确保数据的一致性和可预测性。

### 核心状态属性
- `state.novelName`：存储当前选中的小说名称。
- `state.selectedChapterPaths`：存储用户选中的章节文件路径数组。
- `state.characterMapping`：对象，键为角色名，值为分配的音色名，实现角色到音色的映射。
- `state.novelData`：存储当前编辑章节的原始数据，用于内容编辑和音频生成。
- `state.generatedFiles`：对象，键为行索引，值为已生成的音频文件名，跟踪生成状态。
- `state.globalConfig`：存储从后端获取的全局配置，包括模型设置、代理配置和音频导出选项。

### 状态初始化
在`initialize()`函数中，应用首先从`/api/get_llm_config`端点获取全局配置并存储在`state.globalConfig`中。随后调用`loadNovels()`和`loadTimbres()`加载小说列表和音色库，完成初始状态的构建。

### 状态更新机制
状态更新主要通过用户操作和API响应触发。例如，当用户上传新小说时，`handleTxtFileUpload`函数会更新`state.allNovelsData`并重新渲染UI。选择小说时，`handleNovelSelection`函数会更新`state.novelName`并加载相关数据。

**Section sources**
- [index.html](file://index.html#L1236-L1251)
- [index.html](file://index.html#L4085-L4154)

## 事件监听与用户交互
前端通过事件监听器响应用户操作，实现丰富的交互体验。

### 文件上传处理
“上传新小说”按钮点击后，触发隐藏的文件输入框。文件选择后，`handleTxtFileUpload`函数被调用，使用`FormData`对象封装文件并通过`fetch`上传到`/api/upload_txt_novel`端点。

### 章节选择与操作
章节列表的复选框变化会触发`handleChapterSelectionChange`函数，该函数更新`state.selectedChapterPaths`并调用`updateGlobalButtons`来启用或禁用全局操作按钮。Shift键多选功能通过记录上一次点击的索引实现范围选择。

### 按钮点击事件
- “处理文本”按钮：调用`processTxtChapters`函数，向后端发送`/api/process_single_chapter`请求，处理选中的TXT章节。
- “生成声音”按钮：调用`processAllAndSplice`函数，遍历选中章节，为每行内容生成音频并最终拼接成完整章节音频。
- “保存配置”按钮：调用`saveConfig`函数，将`state.characterMapping`通过`/api/update_config`端点保存到服务器。

### 模态框交互
各种模态框（如音色上传、角色管理、系统设置）通过点击按钮打开，点击关闭按钮或模态框背景关闭。例如，音色上传模态框在确认后调用`handleTimbreUpload`函数，将音色文件和元数据上传到`/api/upload_timbre`端点。

**Section sources**
- [index.html](file://index.html#L3375-L3517)
- [index.html](file://index.html#L3439-L3442)

## 前端API客户端实现
前端通过封装的`fetchFromServer`函数调用后端RESTful API，处理JSON响应。

### 核心API调用
- `/api/upload_txt_novel`：上传TXT小说文件，后端返回新项目的详细信息。
- `/api/process_single_chapter`：处理单个章节，可选择预览模式获取原文。
- `/api/get_novel_content`：获取已处理章节的JSON内容，用于编辑器加载。
- `/api/tts_v2`：调用TTS服务生成音频，需提供音色参考音频、文本和推理模式。
- `/api/splice_audio`：将多个音频片段拼接成完整章节音频。
- `/api/get_config`：获取小说的音色配置。
- `/api/update_config`：保存音色配置。

### 请求与响应处理
所有API调用均使用`fetch`函数，设置`Content-Type`为`application/json`。请求体通过`JSON.stringify`序列化。成功响应返回JSON对象，包含`status`字段（如`success`）和数据；错误响应也返回JSON，包含`status`（如`error`）和`message`。前端根据`status`更新全局状态栏和UI。

### 错误处理与重试
关键操作（如音频生成）实现了重试逻辑。`generateSpeech`函数在失败时最多重试3次，每次间隔2秒，提高操作的可靠性。网络错误和API错误均被捕获并显示在状态栏。

**Section sources**
- [index.html](file://index.html#L2042-L2076)
- [index.html](file://index.html#L2079-L2227)

## UI组件交互逻辑
各UI组件之间存在紧密的交互逻辑，确保工作流的顺畅。

### 小说选择与章节加载
当用户在`novelSelector`下拉框中选择小说时，`handleNovelSelection`函数被触发。该函数首先更新`state.novelName`，然后调用`renderChapterList`渲染该小说的章节列表，并调用`loadAndApplyConfig`加载音色配置。

### 章节选择与内容显示
`handleChapterSelectionChange`函数是内容显示的核心。当用户选择章节时，它会根据选中数量决定显示内容：
- 选中一个已处理章节：显示内容编辑器表格。
- 选中一个未处理的TXT章节：显示原文预览。
- 选中多个或零个章节：显示批量操作提示。

### 音色分配与预览
在音色库中点击“分配”按钮，会将音色分配给`state.selectedCharacter`。分配后，`loadCharacters`函数被调用，重新渲染角色列表以反映新状态。点击“试听”按钮会调用`toggleSimpleAudio`，使用`Audio`对象播放音色样本。

### 配置保存与实时更新
修改TTS模型或推理模式会实时更新`state.novelData`，并调用`markChapterAsDirty`标记章节为“脏”状态，激活“保存对本章节的修改”按钮。保存后，配置被持久化到服务器。

**Section sources**
- [index.html](file://index.html#L1743-L1830)
- [index.html](file://index.html#L2566-L2583)

## 样式组织与设计
`style.css`文件采用模块化方式组织样式，确保代码的可维护性。

### 响应式设计
使用CSS Grid布局`main-container.spa-layout`，定义四列的灵活比例。`scrollable-content`类确保各列内容可独立滚动，提升用户体验。

### 按钮状态样式
定义了`.btn`、`.btn-primary`、`.btn-danger`等基础按钮类，通过`hover`和`disabled`伪类实现交互反馈。例如，禁用按钮使用浅灰色背景和文字，明确指示不可操作状态。

### 模态框动画
模态框使用`display: none/flex`控制显示，配合`transition`实现淡入淡出效果。弹出菜单（popover）通过`opacity`和`transform`实现平滑的出现和消失动画。

### 主题与变量
通过`:root`定义CSS自定义属性（如`--primary-color`, `--bg-color`），实现主题化设计。这些变量在全局范围内使用，便于统一风格和后期调整。

**Section sources**
- [style.css](file://style.css#L1-L190)

## 开发调试技巧
### 浏览器开发者工具
- **网络请求监控**：在“网络”(Network)标签页中，可以查看所有`fetch`请求的详细信息，包括请求头、响应体和状态码，便于调试API调用。
- **控制台日志**：使用`console.log`输出关键变量（如`state`对象）和函数执行流程，帮助定位逻辑错误。例如，在`renderCharacterList`函数中打印角色数据。
- **元素检查**：使用“元素”(Elements)标签页检查DOM结构和应用的CSS样式，确保UI按预期渲染。

### 关键函数分析
- `handleTxtFileUpload`：处理文件上传的核心函数，负责创建`FormData`、发送请求和更新UI状态。
- `processAllAndSplice`：实现批量处理和音频拼接的主要逻辑，包含错误处理和进度更新。

**Section sources**
- [index.html](file://index.html#L1263-L1307)
- [index.html](file://index.html#L2079-L2227)