# 核心功能详解

<cite>
**Referenced Files in This Document**   
- [serverV2.py](file://serverV2.py)
- [index.html](file://index.html)
- [config.json](file://config.json)
</cite>

## 目录
1. [小说管理功能](#小说管理功能)
2. [章节处理功能](#章节处理功能)
3. [角色管理功能](#角色管理功能)
4. [音色配置功能](#音色配置功能)
5. [内容编辑功能](#内容编辑功能)
6. [语音生成功能](#语音生成功能)
7. [音频导出功能](#音频导出功能)
8. [音色库管理功能](#音色库管理功能)
9. [系统设置功能](#系统设置功能)

## 小说管理功能

本系统的小说管理功能主要涵盖新小说的上传、现有小说的删除以及小说列表的展示。这些功能通过前端界面与后端API的协同工作来实现。

**前端UI操作**：
- **上传新小说**：用户点击“上传新小说”按钮，选择一个`.txt`格式的小说文件。系统会自动读取文件名作为小说项目名称，并将文件上传至服务器。
- **删除小说**：用户在“小说项目”下拉菜单中选择一个小说，然后点击“🗑️”删除按钮。系统会弹出一个确认对话框，要求用户输入“删除”以确认操作，防止误删。
- **列表展示**：系统启动后，会自动从`projects`目录中扫描所有小说项目，并在“小说项目”下拉菜单中列出。每个小说项目会显示其名称，用户可以随时切换。

**后端API实现**：
- **上传新小说 (`handleTxtFileUpload`)**：后端通过`/api/upload_txt_novel` API接收上传的文件。该API会将文件内容以UTF-8编码保存到`projects/{novel_name}/source.txt`路径下，并创建一个`.is_txt_project`标记文件。同时，系统会调用`get_chapters_from_txt`函数智能分割章节，并将章节列表缓存到`chapters_cache.json`文件中，以便前端快速加载。
- **删除小说 (`deleteNovelBtn`)**：后端通过`/api/delete_novel` API处理删除请求。该API会接收小说名称，进行严格的安全检查（防止目录遍历攻击），然后递归删除`projects/{novel_name}`和`output/{novel_name}`两个目录下的所有文件和子目录。
- **列表展示 (`list_novels API`)**：后端通过`/api/list_novels` API提供小说列表。该API会扫描`projects`目录，为每个小说项目构建一个包含章节信息（标题、处理状态、拼接状态）和项目类型的详细对象，并返回给前端。

**Section sources**
- [serverV2.py](file://serverV2.py#L1543-L1608)
- [serverV2.py](file://serverV2.py#L897-L946)
- [serverV2.py](file://serverV2.py#L1610-L1663)
- [index.html](file://index.html#L416-L425)

## 章节处理功能

章节处理功能是将原始的`.txt`小说文本智能地分割成独立的章节，并为后续的语音生成做准备。

**前端UI操作**：
- **智能分割**：当用户上传一个新小说或选择一个已存在的小说时，系统会自动调用后端API获取章节列表。章节列表会显示在“章节列表”区域，用户可以进行多选。
- **过滤与选择**：用户可以点击“过滤 🔍”按钮，弹出一个过滤器对话框。用户可以选择“显示全部”、“只显示已处理”或“只显示未处理”的章节，也可以通过“从第...到第...章”的范围来筛选章节。
- **批量处理逻辑**：用户在章节列表中勾选一个或多个章节后，点击“处理文本”按钮，系统会将选中的章节发送到后端进行批量处理。

**后端API实现**：
- **智能分割算法 (`get_chapters_from_txt`)**：该函数是章节处理的核心。它使用一个复杂的正则表达式来匹配所有可能的章节标题行（如“第一章”、“第100回”、“101”等）。然后，它通过特征工程（如是否为独立行、是否包含“章”字、是否为连续编号等）对候选行进行加权评分，识别出最可能的章节模式。最后，根据该模式精确地分割出章节内容，并返回一个包含标题和内容的字典列表。
- **过滤与选择**：后端API `/api/get_novel_details` 会返回每个章节的`processed`（是否已处理）和`spliced`（是否已拼接）状态。前端根据这些状态信息来决定如何显示和过滤章节。
- **批量处理逻辑**：后端通过`/api/process_single_chapter` API处理单个章节。当需要批量处理时，前端会为每个选中的章节发起一个独立的API调用。该API会调用`generate_chapter_json`函数，利用配置的LLM模型（如Gemini）将章节文本转换为包含说话者、内容、语气等信息的JSON结构。

**Section sources**
- [serverV2.py](file://serverV2.py#L1234-L1373)
- [serverV2.py](file://serverV2.py#L816-L862)
- [serverV2.py](file://serverV2.py#L1081-L1230)
- [index.html](file://index.html#L436-L438)

## 角色管理功能

角色管理功能允许系统自动识别小说中的角色，并对其进行深度分析和管理。

**前端UI操作**：
- **自动识别 (`analyze_character`)**：当一个章节被处理后，系统会自动分析其中出现的角色。用户可以在“角色-音色配置”列中看到所有被识别出的角色。点击角色名称旁的“i”图标，可以查看该角色的简介。
- **简介生成**：角色的简介由后端LLM模型生成，包括角色的性别、年龄段和身份背景描述。
- **深度分析**：用户可以点击“深度分析”按钮，系统会聚合该角色在所有已处理章节中的对话，再次调用LLM模型进行更深入的分析，以补全简介信息。
- **名称合并 (`merge_characters API`)**：用户可以点击“角色名管理”按钮，进入角色管理模式。在此模式下，用户可以选择多个角色名，将它们合并到一个主角色名下。合并后，系统会自动更新所有相关章节的JSON文件。

**后端API实现**：
- **自动识别与简介生成**：后端通过`analyze_character`函数实现。该函数会构造一个包含角色名称和上下文文本的提示词（prompt），发送给LLM模型。模型返回一个包含`gender`、`ageGroup`和`identity`字段的JSON对象，系统将其保存到`character_profiles.json`文件中。
- **深度分析**：后端通过`/api/deep_analyze_character` API实现。该API会先读取角色的现有简介，然后遍历所有已处理的章节，聚合该角色的所有对话内容，再调用`complete_character_profile`函数，请求LLM模型补全简介中缺失的字段。
- **名称合并**：后端通过`/api/merge_characters` API实现。该API会接收目标角色名、源角色名列表和章节文件列表。它会遍历所有指定的章节JSON文件，将源角色名替换为目标角色名。一个关键的优化是，如果源角色和目标角色使用了相同的音色，系统会自动重命名对应的WAV音频文件，避免了重新生成语音的开销。

**Section sources**
- [serverV2.py](file://serverV2.py#L594-L680)
- [serverV2.py](file://serverV2.py#L767-L814)
- [serverV2.py](file://serverV2.py#L358-L478)
- [index.html](file://index.html#L462)

## 音色配置功能

音色配置功能允许用户为每个角色分配特定的音色，并支持临时覆盖。

**前端UI操作**：
- **为角色分配音色**：在“角色-音色配置”列中，每个角色下方都有一个下拉菜单，用户可以从音色库中选择一个音色分配给该角色。这个配置会被保存到`character_timbres.json`文件中。
- **临时覆盖机制**：在“内容编辑器”中，用户可以为每一行对话单独设置一个“音色”字段。这个设置会覆盖角色的全局音色配置，实现更精细的控制。
- **保存至 `character_timbres.json`**：当用户点击“保存当前配置”按钮时，前端会将当前所有角色的音色分配信息收集起来，通过`/api/update_config` API发送到后端，后端将其保存为`projects/{novel_name}/character_timbres.json`文件。

**后端API实现**：
- **为角色分配音色**：这是一个前端状态管理功能，后端不直接参与分配过程，而是通过`/api/get_config` API提供当前的音色配置供前端读取。
- **临时覆盖机制**：在生成语音时，后端的`/api/tts_v2` API会优先使用JSON内容中`timbre_override`字段的值，如果该字段为空，则使用`character_timbres.json`中配置的全局音色。
- **保存至 `character_timbres.json`**：后端通过`/api/update_config` API实现。该API接收一个`UpdateConfigRequest`对象，其中包含小说名称和配置数据，然后将其写入对应的JSON文件。

**Section sources**
- [serverV2.py](file://serverV2.py#L1715-L1726)
- [serverV2.py](file://serverV2.py#L1708-L1713)
- [serverV2.py](file://serverV2.py#L1728-L1856)
- [index.html](file://index.html#L465)

## 内容编辑功能

内容编辑功能提供了一个表格化的编辑器，允许用户直接修改已处理章节的内容。

**前端UI操作**：
- **表格化编辑器 (`renderContentTable`)**：当用户在章节列表中选择一个已处理的章节时，其内容会以表格形式显示在“内容编辑器”区域。表格包含“操作”、“#”、“角色”、“音色”、“内容”、“TTS模型”和“操作”等列。
- **插入/删除行**：用户可以通过点击行首的“+”按钮在当前行下方插入新行，或点击“X”按钮删除当前行。新行会继承上一行的角色和音色信息。
- **保存修改 (`update_chapter_content API`)**：用户编辑完成后，点击“保存对本章节的修改”按钮。前端会将整个表格内容序列化为一个JSON数组，并通过API发送到后端保存。

**后端API实现**：
- **表格化编辑器**：这是一个纯前端功能，后端不参与表格的渲染。
- **插入/删除行**：这也是一个前端功能，用户操作会直接修改前端的JSON数据模型。
- **保存修改**：后端通过`/api/update_chapter_content` API实现。该API接收一个`UpdateChapterRequest`对象，其中包含文件路径和新的内容数组。后端会进行路径安全检查，然后将新的JSON内容写入到`projects/{novel_name}/chapters_json/{chapter_name}.json`文件中。

**Section sources**
- [serverV2.py](file://serverV2.py#L2009-L2045)
- [index.html](file://index.html#L500-L523)

## 语音生成功能

语音生成功能负责将文本内容转换为语音音频。

**前端UI操作**：
- **单句生成 (`tts_v2`)**：在“内容编辑器”表格中，每一行都有一个“生成”按钮。用户点击后，系统会收集该行的文本、角色、音色等信息，调用后端API生成单句语音。
- **批量处理**：用户点击“生成声音”按钮，系统会为当前章节中所有未生成语音的行批量调用单句生成API。
- **音频特效**：每行生成的语音文件名旁有一个“特效”按钮，点击后可以应用“手机”、“喇叭”或“回声”等音频特效。
- **播放预览**：生成的语音文件名会显示为一个可点击的播放按钮，用户可以随时预览。

**后端API实现**：
- **单句生成 (`tts_v2`)**：后端通过`/api/tts_v2` API实现。该API会先应用替换词典规则，然后向配置的TTS微服务（如CosyVoice2）发送请求。API内部实现了重试机制，如果生成的音频结尾能量过高（可能被截断），会自动重试，直到成功或达到最大重试次数。
- **批量处理**：由前端发起多个并行的`/api/tts_v2`调用实现。
- **音频特效 (`apply_audio_effect`)**：后端通过`/api/apply_effect` API实现。该API会加载指定的WAV文件，根据`effect_type`参数应用不同的音频处理。例如，“手机”效果会应用高通和低通滤波器，并将采样率降至8000Hz再升回，以模拟电话音质。
- **播放预览**：前端通过直接访问`/output`或`/wav`静态文件目录来播放音频，无需后端API。

**Section sources**
- [serverV2.py](file://serverV2.py#L1728-L1862)
- [serverV2.py](file://serverV2.py#L1376-L1433)
- [index.html](file://index.html#L522)

## 音频导出功能

音频导出功能负责将单句语音拼接成完整的章节音频，并提供下载。

**前端UI操作**：
- **拼接逻辑 (`splice_audio`)**：用户点击“下载声音”按钮，系统会先调用拼接API。拼接完成后，按钮会变为“下载”。
- **下载单个音频**：在“内容编辑器”中，用户可以直接点击单句语音的文件名进行下载。
- **打包下载 (`download_spliced_chapters`)**：当用户选择了多个已拼接的章节并点击“下载声音”时，系统会调用打包下载API，将这些章节的音频文件打包成一个ZIP文件供用户下载。

**后端API实现**：
- **拼接逻辑 (`splice_audio`)**：后端通过`/api/splice_audio` API实现。该API会根据章节的JSON内容和音色配置，构建一个需要拼接的WAV文件列表。然后使用`pydub`库将这些音频文件按顺序连接起来，最后根据`config.json`中的设置（格式、质量）导出为MP3、WAV等格式的文件。
- **下载单个音频**：通过`app.mount("/output", StaticFiles(...))`挂载的静态文件服务实现。
- **打包下载 (`download_spliced_chapters`)**：后端通过`/api/download_spliced_chapters` API实现。该API接收一个文件路径列表，在内存中创建一个ZIP文件，将所有指定的音频文件添加进去，然后使用`StreamingResponse`流式返回给前端，支持大文件下载。

**Section sources**
- [serverV2.py](file://serverV2.py#L1864-L1956)
- [serverV2.py](file://serverV2.py#L2350-L2411)
- [serverV2.py](file://serverV2.py#L2496-L2497)

## 音色库管理功能

音色库管理功能用于管理可用的音色资源。

**前端UI操作**：
- **上传音色 (`upload_timbre`)**：用户点击“上传新音色”按钮，选择一个音频文件（如WAV、MP3）。在弹出的对话框中，用户需要输入音色名称、参考文本，并可选择是否进行音量标准化。
- **分类管理 (`move_timbre`)**：在“音色库”列中，用户可以通过音色名称旁的“...”菜单，选择“移动到分类”来管理音色的分类。
- **删除音色 (`delete_timbre`)**：在音色的“...”菜单中，有“删除音色”选项，用户可以删除不再需要的音色。
- **试听功能**：每个音色名称旁都有一个“▶”播放按钮，用户可以随时试听该音色的参考音频。

**后端API实现**：
- **上传音色 (`upload_timbre`)**：后端通过`/api/upload_timbre` API实现。该API会将上传的音频文件转换为单声道WAV格式，可选地进行音量标准化，然后保存到`wav/{timbre_name}/1.wav`。同时，参考文本保存为`1.txt`，并在`timbre_categories.json`中记录该音色。
- **分类管理 (`move_timbre`)**：后端通过`/api/timbres/move`和`/api/timbres/set_category` API实现。这些API会修改`timbre_categories.json`文件，将音色从一个分类移动到另一个分类或“未分类”。
- **删除音色 (`delete_timbre`)**：后端通过`/api/delete_timbre` API实现。该API会先从`timbre_categories.json`中移除音色记录，然后安全地删除`wav/{timbre_name}`整个目录。
- **试听功能**：通过`app.mount("/wav", StaticFiles(...))`挂载的静态文件服务实现。

**Section sources**
- [serverV2.py](file://serverV2.py#L2225-L2287)
- [serverV2.py](file://serverV2.py#L2157-L2183)
- [serverV2.py](file://serverV2.py#L2291-L2346)
- [index.html](file://index.html#L483-L484)

## 系统设置功能

系统设置功能主要管理全局的替换词典。

**前端UI操作**：
- **替换词典管理 (`replace_dict CRUD操作`)**：用户在“小说管理与处理”列中点击“管理替换词典”按钮，会弹出一个替换词典管理对话框。用户可以添加、编辑、删除替换规则。每个规则包含“原词”、“替换为”和“描述”三个字段。

**后端API实现**：
- **替换词典管理 (`replace_dict CRUD操作`)**：后端通过`/api/novel/{novel_name}/replace_dict` API实现。`GET`请求用于获取当前小说的替换词典规则，`POST`请求用于保存用户修改后的规则到`projects/{novel_name}/replace_dict.json`文件。在生成语音时，`apply_replacement_rules`函数会加载并应用这些规则，对TTS文本进行预处理。

**Section sources**
- [serverV2.py](file://serverV2.py#L1959-L2007)
- [serverV2.py](file://serverV2.py#L521-L559)
- [index.html](file://index.html#L463)