# 音色库管理

<cite>
**本文档引用文件**   
- [serverV2.py](file://serverV2.py)
- [index.html](file://index.html)
</cite>

## 目录
1. [音色上传流程](#音色上传流程)
2. [分类管理机制](#分类管理机制)
3. [删除功能](#删除功能)
4. [试听功能](#试听功能)
5. [文件命名与处理策略](#文件命名与处理策略)
6. [扩展建议](#扩展建议)

## 音色上传流程

音色上传功能由前端 `handleTimbreUpload` 函数与后端 `/api/upload_timbre` 接口协同实现。用户通过界面选择音频文件后，前端将文件、音色名称、参考文本、分类信息及音量标准化选项封装为 `FormData` 对象，并通过 `fetch` 方法提交至后端。

后端 `upload_timbre` 函数首先检查音色名称是否已存在，若存在则返回冲突错误。随后，文件被暂存于 `temp/` 目录下。系统使用 `pydub` 库加载音频，根据用户选择执行音量标准化处理，并将音频统一转换为单声道。处理完成后，系统在 `wav/` 目录下创建以音色名称命名的文件夹，并将音频文件保存为 `1.wav`，同时将参考文本保存为 `1.txt`。最后，系统更新 `timbre_categories.json` 文件，将新音色记录添加至指定分类或“未分类”列表中。

**Section sources**
- [serverV2.py](file://serverV2.py#L2225-L2288)
- [index.html](file://index.html#L1679-L1745)

## 分类管理机制

音色库的分类管理通过 `dom_timbres_manager` 界面进行操作，其核心是维护一个名为 `timbre_categories.json` 的分类数据文件。该文件采用 JSON 格式，包含 `"categories"`（分类字典）和 `"unassigned"`（未分类列表）两个顶级键。

用户在管理界面中创建新分类时，前端调用 `/api/timbres/categories` 接口，后端 `create_new_category` 函数会在 `timbre_categories.json` 的 `categories` 字典中添加一个空列表。移动音色的操作通过 `/api/timbres/set_category` 或 `/api/timbres/move` 接口实现。后端 `set_timbre_category` 函数会先从所有分类和“未分类”列表中移除该音色的旧记录，然后根据用户选择，将其添加到新的分类或“未分类”列表中，并对列表进行排序以保证一致性。

**Section sources**
- [serverV2.py](file://serverV2.py#L2101-L2122)
- [serverV2.py](file://serverV2.py#L2130-L2142)
- [serverV2.py](file://serverV2.py#L2194-L2223)
- [index.html](file://index.html#L2455-L2614)

## 删除功能

删除功能通过调用 `delete_timbre` API 实现，该 API 提供了安全的音色文件删除机制。当接收到删除请求时，系统首先从 `timbre_categories.json` 文件中移除该音色的所有记录，无论其位于哪个分类或“未分类”列表中。

随后，系统构建目标音色文件夹的路径，并通过 `os.path.realpath` 解析其真实路径，确保该路径位于合法的 `WAV_DIR` 目录内部，从而有效防止目录遍历攻击。在确认文件夹存在后，系统使用 `shutil.rmtree` 递归删除整个音色文件夹及其所有内容。整个过程包含完整的异常处理，确保操作的原子性和安全性。

**Section sources**
- [serverV2.py](file://serverV2.py#L2291-L2346)

## 试听功能

音色试听功能的实现依赖于前端的 `Audio` 对象。在音色库列表的渲染过程中，每个音色条目都包含一个带有 `data-timbre-name` 属性的播放按钮。当用户点击播放按钮时，前端事件监听器会捕获该事件，并根据音色名称构造指向 `wav/` 目录下对应 `1.wav` 文件的 URL。

系统创建一个 `Audio` 对象，将其 `src` 属性设置为该 URL，并调用 `play()` 方法开始播放。为了管理播放状态，系统在关闭管理模态框或执行其他操作前会调用 `stopAllAudio()` 函数，停止所有正在播放的音频，避免多个音频同时播放造成混乱。

**Section sources**
- [index.html](file://index.html#L2518-L2543)
- [index.html](file://index.html#L1679-L1688)

## 文件命名与处理策略

系统采用严格的文件命名和处理策略以确保一致性。每个音色在 `wav/` 目录下拥有一个独立的文件夹，文件夹名称即为音色名称。文件夹内仅包含两个固定文件：`1.wav`（音频样本）和 `1.txt`（参考文本），这种命名方式简化了文件管理。

在上传过程中，系统会对音频文件进行 MIME 类型验证（通过浏览器的 `accept="audio/*"` 属性实现）和格式转换，确保所有音频最终都以 WAV 格式存储。对于重复的音色名称，系统在上传时会直接拒绝，避免覆盖。此外，系统通过 `uuid.uuid4()` 生成唯一的临时文件名来处理上传过程中的临时文件，有效防止了临时文件的命名冲突。

**Section sources**
- [serverV2.py](file://serverV2.py#L2239-L2242)
- [serverV2.py](file://serverV2.py#L2260-L2263)
- [index.html](file://index.html#L484)

## 扩展建议

### 音色元数据扩展

当前系统仅存储音色名称和参考文本。为增强管理能力，建议扩展音色元数据。可在音色文件夹内引入 `metadata.json` 文件，用于存储作者、标签、创建日期、语言、性别等信息。前端界面可提供一个元数据编辑器，允许用户在上传或管理音色时填写这些信息。后端在返回音色列表时，一并返回这些元数据，前端可根据标签进行筛选和搜索，极大提升大规模音色库的管理效率。

### 大规模音色库索引优化

随着音色库规模扩大，基于 `timbre_categories.json` 文件的读写操作可能成为性能瓶颈。建议引入轻量级数据库（如 SQLite）来替代 JSON 文件存储。将音色信息、分类关系和元数据存储在数据库表中，利用数据库的索引能力，可以显著提升分类查询、标签搜索和列表加载的速度。同时，数据库的事务机制能更好地保证数据一致性，避免在高并发操作下可能出现的文件读写冲突。