# 章节处理

<cite>
**本文档引用的文件**   
- [serverV2.py](file://serverV2.py)
- [index.html](file://index.html)
- [config.json](file://config.json)
</cite>

## 目录
1. [智能分割算法](#智能分割算法)
2. [章节过滤与选择机制](#章节过滤与选择机制)
3. [批量处理逻辑](#批量处理逻辑)
4. [边界条件与性能优化](#边界条件与性能优化)
5. [常见问题与扩展建议](#常见问题与扩展建议)

## 智能分割算法

章节智能分割功能的核心在于后端 `serverV2.py` 文件中实现的 `get_chapters_from_txt` 函数。该函数通过一个加权的、基于启发式规则的引擎，对连续文本进行智能切分，最终生成独立的章节JSON对象。

前端通过调用 `processTxtChapters` 函数，触发对 `/api/process_single_chapter` 的POST请求，将小说名称和章节标题作为参数传递给后端。后端接收到请求后，会执行 `get_chapters_from_txt` 函数。

该函数的实现分为三个阶段：
1.  **候选生成与特征工程**：使用一个综合性的正则表达式来匹配所有潜在的章节行，包括“第X章”、“第X回”、纯数字、汉字数字等多种模式。对于每个匹配项，函数会提取其文本、位置、长度、是否包含“章”“回”等关键词、是否为独立行（下一行为空）以及是否为连续编号等特征。
2.  **加权评分与决策**：为每个候选行的特征分配权重进行评分。例如，“独立行”和“包含章节关键词”会获得较高的正向分数，而“行过长”则会受到严重惩罚。系统会计算每种模式（如`formal_chapter`）的平均得分，并将得分最高的模式视为该文本的“主导章节模式”。
3.  **精确提取**：根据上一阶段确定的“主导章节模式”，筛选出所有符合该模式的候选行作为最终的章节标题。然后，以这些标题的位置为分割点，将原始文本切分成多个独立的章节块，并为每个块生成包含“标题”和“内容”字段的JSON对象。

**Section sources**
- [serverV2.py](file://serverV2.py#L1234-L1373)
- [index.html](file://index.html#L1407-L1433)

## 章节过滤与选择机制

用户通过前端界面的复选框来批量选择目标章节。当用户在小说管理与处理区域（第一列）勾选或取消勾选章节时，前端会实时记录这些选择状态。

前端通过一个名为 `state.selectedChapterPaths` 的全局状态变量来管理所有被选中章节的路径。每当用户点击复选框时，`handleChapterSelectionChange` 函数会被调用，该函数负责更新 `state.selectedChapterPaths` 数组，并同步更新全局按钮（如“处理文本”、“生成声音”）的启用/禁用状态和显示文本。

例如，当用户选中一个未处理的TXT章节时，`processTxtBtn` 按钮会变为可用状态，并显示“处理文本 (1)”，其中的数字表示当前选中待处理的章节数量。这种状态管理机制确保了用户操作与系统功能的紧密联动。

**Section sources**
- [index.html](file://index.html#L3418-L3442)
- [index.html](file://index.html#L2290-L2327)

## 批量处理逻辑

批量处理的核心逻辑由前端 `index.html` 文件中的 `processAllAndSplice` 函数协调完成。该函数负责协调多个API调用，依次处理用户选中的所有章节，并触发后续的语音生成与拼接。

其工作流程如下：
1.  **状态检查与初始化**：函数首先检查当前是否已有处理任务在运行。如果没有，则进入处理流程，并将 `state.isProcessing` 标志设为 `true`，同时更新UI按钮状态。
2.  **筛选待处理章节**：函数会从所有被选中的复选框中，筛选出文件路径以 `.json` 结尾的项，这些项代表已经过文本处理的章节。
3.  **循环处理**：函数使用 `for` 循环遍历所有待处理的章节。对于每一个章节，它会：
    *   构造一个包含章节路径、角色、音色等信息的TTS请求体。
    *   调用 `fetchFromServer('/api/tts_v2', ...)` 向后端发起TTS语音生成请求。
    *   等待该请求完成（或失败）后，再处理下一个章节。
4.  **拼接音频**：当所有章节的语音生成任务都成功完成后，函数会调用 `/api/splice_audio` 接口，将生成的单句音频文件按顺序拼接成完整的章节音频。

**Section sources**
- [index.html](file://index.html#L2066-L2101)
- [index.html](file://index.html#L2180-L2203)

## 边界条件与性能优化

### 边界条件处理
`get_chapters_from_txt` 函数在处理边界条件时表现稳健：
*   **空行处理**：函数通过检查候选行的下一行是否为空来判断其是否为“独立行”，这是识别章节标题的关键特征之一。
*   **标题格式**：正则表达式设计得非常包容，能够匹配多种常见的中文章节标题格式，包括带括号的数字 `(101)` 和汉字数字 `一百零一`。
*   **无章节文本**：如果输入文本中没有找到任何候选章节，函数会检查文本内容是否为空。如果非空，则返回一个空列表，避免了错误。

### 性能优化策略
系统在性能优化方面采用了异步处理队列的思想：
*   **后端重试机制**：在 `tts_v2` API 中，后端实现了内部重试逻辑。当TTS服务返回的音频可能被截断时（通过分析结尾能量判断），后端会自动进行重试，无需前端反复请求，这提高了单次请求的成功率。
*   **前端任务队列**：`processAllAndSplice` 函数通过 `for` 循环顺序处理章节，这本质上是一个简单的任务队列。虽然没有使用并发，但通过 `await` 关键字确保了每个TTS请求都完成后再进行下一个，保证了处理的有序性，避免了对后端服务的瞬时高并发冲击。

**Section sources**
- [serverV2.py](file://serverV2.py#L1800-L1824)
- [index.html](file://index.html#L2066-L2101)

## 常见问题与扩展建议

### 常见分割错误排查
*   **分割失败，返回空列表**：首先检查原始文本的编码是否为UTF-8。其次，确认章节标题的格式是否过于特殊，超出了正则表达式 `candidate_regex` 的匹配范围。
*   **章节内容错乱**：这通常是由于“主导章节模式”判断错误导致的。可以检查文本中是否存在大量干扰性的数字或关键词，导致评分系统误判。建议在文本开头使用统一、规范的章节标题格式。

### 自定义分割规则扩展建议
当前的分割算法基于启发式规则和加权评分。若需扩展自定义规则，建议在 `get_chapters_from_txt` 函数的“加权评分”阶段进行修改：
1.  可以在 `pattern_scores` 字典中增加新的模式类型（如 `custom_pattern`）。
2.  在特征提取阶段，为新的模式添加相应的判断逻辑。
3.  调整各特征的权重分值，以适应特定文本的分割需求。例如，对于标题行必须为独立行的文本，可以将 `is_standalone` 的权重从50分提高到100分。