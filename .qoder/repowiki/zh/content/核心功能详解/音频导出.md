# 音频导出

<cite>
**本文档引用文件**   
- [serverV2.py](file://serverV2.py)
- [config.json](file://config.json)
- [index.html](file://index.html)
</cite>

## 目录
1. [音频拼接逻辑](#音频拼接逻辑)
2. [单个音频下载机制](#单个音频下载机制)
3. [打包下载功能](#打包下载功能)
4. [文件流处理与内存优化](#文件流处理与内存优化)
5. [大文件导出与磁盘预警](#大文件导出与磁盘预警)

## 音频拼接逻辑

系统通过调用 `/api/splice_audio` 接口实现音频拼接功能。后端服务在 `serverV2.py` 文件中定义了 `splice_audio` 函数，该函数利用 `pydub` 库按章节顺序合并 WAV 文件。拼接过程首先根据章节的 JSON 配置文件构建权威的音频文件列表，确保与前端逻辑一致。对于列表中的每个 WAV 文件，系统会检查其存在性并按序加载，通过 `AudioSegment` 的 `+=` 操作符进行无缝拼接。为提升听觉体验，系统在拼接时自动应用淡入淡出过渡效果。最终，合并后的音频流根据全局配置导出为 MP3 文件，并存储在 `output/` 目录下。导出格式和质量由 `config.json` 中的 `audio_export` 配置项决定，支持 MP3、WAV、M4A 和 OGG 等多种格式。

**Section sources**
- [serverV2.py](file://serverV2.py#L1864-L1956)

## 单个音频下载机制

前端通过直接链接的方式提供已生成的单个音频片段下载。当用户在内容编辑器中点击播放按钮时，系统会根据小说名称、章节名称和音色信息，通过 `sanitizeTitleForFilename` 函数对标题进行安全化处理，以匹配后端生成的文件名。随后，系统构建指向 `/output/{novel_name}/wavs/{chapter_name}/{filename}.wav` 的 URL。该 URL 由 FastAPI 通过 `StaticFiles` 挂载 `/output` 目录而提供服务，允许用户直接访问和下载指定的 WAV 片段。此机制确保了前端请求的 URL 与后端实际存储的文件路径完全一致。

**Section sources**
- [index.html](file://index.html#L3698-L3719)
- [serverV2.py](file://serverV2.py#L2496)

## 打包下载功能

打包下载功能由前端按钮 `downloadSpliceBtn` 触发。当用户点击该按钮时，前端会收集所有已选中且已完成拼接的章节。对于每个符合条件的章节，系统会根据其小说名、安全化后的章节名和配置的音频格式（如 MP3），生成一个相对文件路径（例如 `小说名/章节名.mp3`），并将其添加到 `filePathsToDownload` 数组中。随后，前端通过 POST 请求调用 `/api/download_spliced_chapters` 接口，并将文件路径数组作为请求体发送。服务端的 `download_spliced_chapters` 函数接收请求，使用 `zipfile` 模块在内存中创建一个 ZIP 压缩包，将所有请求的文件写入其中。为防止目录遍历攻击，系统会验证每个文件路径是否位于 `OUTPUT_DIR` 目录下。最终，系统使用 `StreamingResponse` 将 ZIP 文件流式返回给前端，实现一键打包下载所有拼接完成的章节音频。

**Section sources**
- [index.html](file://index.html#L3444-L3509)
- [serverV2.py](file://serverV2.py#L2350-L2410)

## 文件流处理与内存优化

在 `serverV2.py` 的 `splice_audio` 函数中，系统采用了高效的文件流处理策略。音频拼接操作在内存中进行，`pydub` 库将每个 WAV 文件加载为 `AudioSegment` 对象，并通过累加操作合并成一个完整的音频片段。为优化内存使用，系统在拼接完成后立即调用 `combined.export()` 方法，将结果直接写入磁盘，避免了在内存中长期持有大型音频对象。对于打包下载功能，`download_spliced_chapters` 函数使用 `io.BytesIO` 在内存中创建一个 ZIP 缓冲区，所有文件被直接写入此缓冲区，而不是先在磁盘上创建临时 ZIP 文件。这种内存优先的策略显著减少了 I/O 操作，提高了处理速度和系统响应性。同时，`StreamingResponse` 允许服务器在 ZIP 文件生成的同时就开始向客户端传输数据，实现了真正的流式传输，极大地优化了大文件下载的内存占用。

**Section sources**
- [serverV2.py](file://serverV2.py#L1864-L1956)
- [serverV2.py](file://serverV2.py#L2350-L2410)

## 大文件导出与磁盘预警

系统通过多种机制应对大文件导出和磁盘空间问题。首先，`processAllAndSplice` 函数在批量处理章节时会请求屏幕唤醒锁（Screen Wake Lock API），防止长时间任务因设备休眠而中断，确保大文件导出过程的稳定性。其次，在打包下载时，系统会对请求的文件路径进行严格的安全检查，阻止任何试图访问 `OUTPUT_DIR` 目录之外文件的请求，保障了文件系统的安全。虽然当前代码未直接实现磁盘空间预警，但其设计为集成此类功能提供了基础。例如，可以在执行 `splice_audio` 或 `download_spliced_chapters` 之前，调用 `shutil.disk_usage()` 检查目标目录的可用空间，并在空间不足时向用户返回错误信息。此外，通过 `logger.info` 记录关键操作，为监控系统资源使用情况和实现预警机制提供了日志支持。

**Section sources**
- [index.html](file://index.html#L2066-L2101)
- [index.html](file://index.html#L2180-L2203)
- [serverV2.py](file://serverV2.py#L1864-L1956)
- [serverV2.py](file://serverV2.py#L2350-L2410)