# 文本转语音集成

<cite>
**本文档引用的文件**
- [serverV2.py](file://serverV2.py)
- [config.json](file://config.json)
- [index.html](file://index.html)
</cite>

## 目录
1. [tts_v2函数概述](#tts_v2函数概述)
2. [TTS服务端点动态选择](#tts服务端点动态选择)
3. [TTS请求构造与参数传递](#tts请求构造与参数传递)
4. [文本预处理与替换词典](#文本预处理与替换词典)
5. [TTS生成重试与音频质量控制](#tts生成重试与音频质量控制)
6. [tts_models配置结构详解](#tts_models配置结构详解)
7. [用户指南：添加新的TTS服务](#用户指南添加新的tts服务)

## tts_v2函数概述

`serverV2.py` 文件中的 `tts_v2` 函数是系统与CosyVoice2、IndexTTS2等文本转语音（TTS）微服务集成的核心。该函数作为FastAPI后端的一个API端点，接收前端发送的文本、音色、提示音频等参数，经过一系列处理后，向指定的TTS微服务发起HTTP请求，最终将生成的音频文件保存到服务器指定目录。此函数不仅负责TTS请求的转发，还集成了文本预处理、错误处理、内部重试和音频质量检测等关键功能，确保了语音生成过程的稳定性和可靠性。

**Section sources**
- [serverV2.py](file://serverV2.py#L1728-L1862)

## TTS服务端点动态选择

`tts_v2` 函数通过读取 `config.json` 配置文件中的 `tts_models` 字段，实现了对不同TTS微服务的动态选择。其选择逻辑如下：

1.  **加载配置**：函数首先从 `config.json` 文件中加载全局配置。
2.  **确定模型ID**：函数检查请求体（`req`）中是否包含 `tts_model` 字段。如果存在且该ID在 `tts_models` 配置中有效，则使用该ID；否则，使用 `general` 配置项下的 `default_tts_model` 作为默认模型ID。
3.  **获取端点**：根据最终确定的模型ID，从 `tts_models` 配置中查找对应的 `endpoint` 值。该值即为TTS微服务的HTTP地址。
4.  **错误处理**：如果无法确定有效的模型ID或其对应的 `endpoint` 为空，函数将抛出HTTP异常，提示用户配置错误。

这种设计使得系统可以轻松地集成多个TTS服务，并允许用户在运行时通过请求参数或默认配置来灵活切换。

**Section sources**
- [serverV2.py](file://serverV2.py#L1735-L1746)
- [config.json](file://config.json#L16-L24)

## TTS请求构造与参数传递

在确定了目标TTS服务的端点后，`tts_v2` 函数会构造一个包含所有必要信息的JSON payload，并通过HTTP POST请求发送给微服务。请求的构造过程如下：

1.  **文本预处理**：首先，原始文本 `req.tts_text` 会经过 `apply_replacement_rules` 函数进行预处理，生成 `processed_tts_text`。
2.  **构建Payload**：函数创建一个字典，将处理后的文本以及其他关键参数填入：
    *   `tts_text`: 经过替换词典处理后的待合成文本。
    *   `prompt_audio`: 来自音色文件夹的参考音频（以Base64编码的字符串形式）。
    *   `prompt_text`: 来自音色文件夹的参考文本。
    *   `inference_mode`: 推理模式，如 `zero_shot`，用于指导TTS模型的合成方式。
    *   `instruct_text`: 指令文本，用于提供更具体的语音合成指导。
3.  **发起请求**：使用 `requests.post()` 方法，将构建好的payload以JSON格式发送到 `model_endpoint`。

此过程确保了所有必要的上下文信息都被准确地传递给TTS微服务，以生成符合预期的语音。

**Section sources**
- [serverV2.py](file://serverV2.py#L1748-L1757)
- [index.html](file://index.html#L3645-L3670)

## 文本预处理与替换词典

在向TTS微服务发送请求之前，系统会应用一个替换词典来预处理文本。这一功能由 `apply_replacement_rules` 函数实现，其工作流程如下：

1.  **加载规则**：函数根据小说名称（`novel_name`）定位到项目目录下的 `replace_dict.json` 文件，并加载其中的替换规则。
2.  **规则排序**：为了防止短词替换影响长词，所有规则会按照 `original_word` 的长度从长到短进行排序。
3.  **执行替换**：函数遍历排序后的规则列表，使用正则表达式（`re.subn`）在文本中查找并替换匹配的原始词。
4.  **日志记录**：函数会记录成功应用的替换次数，便于调试和监控。

用户可以在前端界面的“替换词典”标签页中管理这些规则，为特定小说定义专有的词汇替换，例如将“林公子”替换为“林某人”，从而确保语音输出的准确性和一致性。

**Section sources**
- [serverV2.py](file://serverV2.py#L521-L559)
- [serverV2.py](file://serverV2.py#L1982-L2002)
- [index.html](file://index.html#L4029-L4083)

## TTS生成重试与音频质量控制

`tts_v2` 函数内置了强大的错误处理和质量控制机制，以应对TTS服务可能的不稳定。

1.  **内部重试机制**：函数包含一个 `for` 循环，最多尝试 `TTS_GENERATION_MAX_RETRIES`（默认为5次）来生成音频。如果某次请求失败（如网络错误、服务返回非成功状态、缺少音频数据），函数会记录日志并等待2秒后进行下一次重试。
2.  **音频结尾截断检测**：这是质量控制的核心。对于每次成功返回的音频，函数会：
    *   使用 `pydub` 库加载音频。
    *   提取音频末尾 `TTS_TAIL_ANALYSIS_DURATION_MS`（默认30毫秒）的片段。
    *   计算该片段的平均能量（`dBFS`）。
    *   将该能量值与 `TTS_TAIL_ENERGY_THRESHOLD_DBFS`（默认-40 dBFS）进行比较。
3.  **结果选择策略**：
    *   如果音频结尾能量低于阈值，说明音频完整，函数会立即保存该结果并退出重试循环。
    *   如果能量高于阈值，说明音频可能被截断。此时，函数会比较本次尝试的结尾能量与之前所有尝试中最低的能量。如果本次能量更低（即“更不戛然而止”），则将其作为当前“最佳”结果保存，并继续重试。
    *   循环结束后，函数会保存在整个重试过程中找到的“最佳”音频数据。

该机制确保了即使在TTS服务偶发性截断的情况下，系统也能通过重试获得最完整的音频。

**Section sources**
- [serverV2.py](file://serverV2.py#L53-L55)
- [serverV2.py](file://serverV2.py#L1764-L1842)

## tts_models配置结构详解

`config.json` 文件中的 `tts_models` 字段是一个JSON对象，用于定义所有可用的TTS服务。其结构如下：

```json
"tts_models": {
    "模型ID": {
        "display_name": "显示名称",
        "endpoint": "服务地址"
    },
    ...
}
```

*   **模型ID (Model ID)**：一个唯一的字符串标识符，用于在代码和配置中引用该TTS服务。例如 `"cosyvoice_v2"`。它也是 `tts_model` 请求参数的取值。
*   **display_name (显示名称)**：一个更友好、可读的名称，用于在前端用户界面中显示。例如 `"CosyVoice2"`。它不参与后端逻辑，仅用于提升用户体验。
*   **endpoint (服务地址)**：一个完整的HTTP URL，指向TTS微服务的API端点。例如 `"http://127.0.0.1:5010/api/tts"`。这是系统实际发起HTTP POST请求的目标地址。

该配置结构清晰地分离了内部标识、用户界面显示和网络地址，使得配置既易于管理又灵活。

**Section sources**
- [config.json](file://config.json#L16-L24)
- [index.html](file://index.html#L3078-L3104)

## 用户指南：添加新的TTS服务

用户可以通过以下步骤在 `config.json` 文件中添加一个新的TTS服务：

1.  **打开配置文件**：使用文本编辑器打开项目根目录下的 `config.json` 文件。
2.  **定位tts_models字段**：在JSON结构中找到 `"tts_models"` 对象。
3.  **添加新条目**：在 `tts_models` 对象内，添加一个新的键值对。键（Key）为自定义的**模型ID**，值（Value）为一个包含 `display_name` 和 `endpoint` 的子对象。
4.  **填写详细信息**：
    *   将 `display_name` 的值设置为希望在前端显示的服务名称。
    *   将 `endpoint` 的值设置为新TTS微服务的完整HTTP地址。
5.  **保存并重启**：保存 `config.json` 文件。如果后端服务正在运行，需要重启它以加载新的配置。

例如，要添加一个名为 `my_new_tts` 的服务，其地址为 `http://127.0.0.1:6000/tts`，可以在 `config.json` 中添加如下内容：
```json
"my_new_tts": {
    "display_name": "我的新TTS服务",
    "endpoint": "http://127.0.0.1:6000/tts"
}
```
添加完成后，该服务将出现在前端的TTS模型选择下拉菜单中。

**Section sources**
- [config.json](file://config.json#L16-L24)
- [index.html](file://index.html#L3078-L3104)