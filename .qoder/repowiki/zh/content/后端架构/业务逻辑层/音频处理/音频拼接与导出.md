# 音频拼接与导出

<cite>
**本文档引用的文件**   
- [serverV2.py](file://serverV2.py)
- [config.json](file://config.json)
</cite>

## 目录
1. [API接口概述](#api接口概述)
2. [音频拼接机制](#音频拼接机制)
3. [音频导出与格式转换](#音频导出与格式转换)
4. [章节音频打包下载](#章节音频打包下载)
5. [权威文件列表构建逻辑](#权威文件列表构建逻辑)

## API接口概述

本系统通过两个核心API端点实现音频的拼接与打包下载功能。`/api/splice_audio`负责将单个WAV音频片段按顺序无缝拼接成完整的章节音频，而`/api/download_spliced_chapters`则负责将多个已拼接的章节音频文件动态打包成ZIP文件并提供下载流。这两个API共同构成了从音频片段到最终成品的自动化处理流程。

**Section sources**
- [serverV2.py](file://serverV2.py#L1864-L1956)
- [serverV2.py](file://serverV2.py#L2350-L2410)

## 音频拼接机制

`splice_audio`函数是音频拼接的核心。该函数接收一个`SpliceRequest`请求，其中包含小说名称（`novel_name`）和章节名称（`chapter_name`）。函数首先根据这些信息构建路径，定位到存储WAV片段的`output/wavs/`目录和存储章节JSON数据的`chapters_json`目录。

拼接过程的关键在于读取章节JSON文件。该文件不仅定义了对话的顺序，还包含了`delay`字段，该字段指定了与上一句之间的停顿时间（以毫秒为单位）。在拼接过程中，函数会遍历JSON数组中的每一个条目，根据其在数组中的索引（`i`）来构建对应的WAV文件名（`{i:04d}-{safe_speaker}-{safe_timbre}.wav`），然后使用`pydub`库的`AudioSegment.from_wav()`方法加载音频，并通过`+=`操作符将其追加到一个空的`AudioSegment`对象上。由于`pydub`的`+=`操作符是直接连接，因此`delay`字段所代表的停顿时间必须在生成单个WAV片段时就已经作为静音添加到音频末尾，`splice_audio`函数本身不负责插入额外的静音间隔。

**Section sources**
- [serverV2.py](file://serverV2.py#L1864-L1956)

## 音频导出与格式转换

在完成音频拼接后，`splice_audio`函数会根据`config.json`文件中的`audio_export`配置来导出最终的音频文件。该配置指定了输出格式（如`mp3`, `m4a`, `ogg`）和质量（如`256k`）。

为了实现格式转换，系统在启动时会检查项目根目录下是否存在`ffmpeg-8.0-full_build`文件夹，并将`pydub`库的音频转换器（`AudioSegment.converter`）指向其中的`ffmpeg.exe`可执行文件。当调用`combined.export()`方法时，`pydub`会自动调用FFmpeg进行编码。例如，当输出格式为MP3时，会将`export_params`中的`bitrate`参数传递给FFmpeg；当输出格式为OGG时，会将`parameters`参数（如`["-q:a", "5"]`）传递给FFmpeg以控制Vorbis编码器的质量。

在导出前，系统会调用`normalize`函数对拼接后的完整音频进行音量标准化。这一步至关重要，因为它可以确保整个章节的音量保持一致，防止因不同片段音量差异过大而导致的“削波”（Clipping）或听感不适，从而保证了最终音频的听觉质量。

**Section sources**
- [serverV2.py](file://serverV2.py#L1864-L1956)
- [config.json](file://config.json#L12-L15)
- [serverV2.py](file://serverV2.py#L2505-L2526)

## 章节音频打包下载

`download_spliced_chapters`函数负责处理多个已拼接章节的打包下载。它接收一个`DownloadRequest`，其中包含一个需要下载的文件路径列表（`file_paths`）。

该函数的核心是使用Python内置的`zipfile`模块。它创建一个`io.BytesIO()`对象作为内存中的字节流缓冲区，并将其作为`ZipFile`的文件句柄。对于请求中的每一个文件路径，函数会检查其安全性（防止目录遍历攻击），确认文件存在后，将其写入ZIP文件对象中。所有文件都添加完毕后，函数将缓冲区的指针重置到开头（`seek(0)`），准备进行流式传输。

为了将打包好的ZIP文件返回给前端，函数使用`StreamingResponse`。这是一个关键设计，因为它允许服务器在不将整个ZIP文件写入磁盘的情况下，直接将内存中的ZIP流分块发送给客户端，极大地提高了效率并节省了磁盘I/O。此外，该函数特别处理了包含中文的文件名。它通过尝试将文件名编码为ASCII来判断是否包含非ASCII字符。如果包含，则使用`Content-Disposition`头的`filename*`参数（遵循RFC 6266标准），将原始文件名进行URL编码后附加在`UTF-8''`之后，同时提供一个纯ASCII的回退文件名（`fallback_filename`），确保在各种操作系统和浏览器上都能正确显示和保存文件。

**Section sources**
- [serverV2.py](file://serverV2.py#L2350-L2410)

## 权威文件列表构建逻辑

`splice_audio`函数在拼接前会动态构建一个待拼接文件的权威列表（`files_to_splice_authoritative`）。这个列表的构建逻辑严格遵循前端的规则，确保了前后端的一致性。

构建过程如下：函数遍历章节JSON文件中的每一个条目。对于每个条目，它首先获取`speaker`（说话者）。然后，它会查找该角色的音色（`timbre`），查找顺序为：1. 检查条目中是否有`timbre_override`字段（音色覆盖）；2. 如果没有，则从`character_timbres.json`配置文件中查找该`speaker`对应的音色。如果成功获取到`speaker`和`timbre`，函数会使用`"".join(c for c in ... if c.isalnum() or c in " _-")`对它们进行安全化处理，移除可能导致文件系统问题的特殊字符，最后按照`{index:04d}-{safe_speaker}-{safe_timbre}.wav`的格式生成文件名并添加到列表中。

这个权威列表的构建是“智能”的，因为它完全依赖于JSON文件和配置文件中的数据，而不是简单地遍历目录。这保证了即使目录中存在多余的WAV文件，也只会拼接那些在JSON文件中被明确指定的、按正确顺序排列的音频片段。

**Section sources**
- [serverV2.py](file://serverV2.py#L1864-L1956)
- [config.json](file://config.json#L209-L240)