# 语音生成

<cite>
**本文档引用的文件**   
- [serverV2.py](file://serverV2.py)
- [config.json](file://config.json)
</cite>

## 目录
1. [引言](#引言)
2. [核心API端点与请求模型](#核心api端点与请求模型)
3. [音色映射与配置管理](#音色映射与配置管理)
4. [文本预处理：替换规则应用](#文本预处理替换规则应用)
5. [TTS生成重试与质量保障机制](#tts生成重试与质量保障机制)
6. [TTS后端选择与请求构造](#tts后端选择与请求构造)
7. [音频文件保存与日志记录](#音频文件保存与日志记录)

## 引言
本文档旨在全面解析文本到语音（TTS）的生成机制。重点阐述`tts_v2` API端点如何接收前端请求，根据`TTSRequestV2`模型中的参数定位生成任务。详细说明音色映射逻辑、文本预处理规则、TTS重试机制、后端选择策略以及音频文件的保存流程。

## 核心API端点与请求模型
系统的核心是`/api/tts_v2`端点，它接收一个名为`TTSRequestV2`的Pydantic模型作为请求体。该模型定义了生成任务所需的所有参数，包括`novel_name`（小说名称）、`chapter_name`（章节名称）、`row_index`（行索引，用于生成文件名）、`speaker`（说话者）、`timbre`（音色名）、`tts_text`（待转换的文本）、`prompt_audio`（参考音频的Base64编码）、`prompt_text`（参考文本）以及`inference_mode`（推理模式）和可选的`tts_model`（TTS模型）。此端点是整个语音生成流程的入口。

**Section sources**
- [serverV2.py](file://serverV2.py#L75-L79)
- [serverV2.py](file://serverV2.py#L1728-L1730)

## 音色映射与配置管理
系统通过`character_timbres.json`文件来管理角色与音色的映射关系。当用户为某个角色选择一个音色时，该信息会被保存在小说项目目录下的`character_timbres.json`文件中。在生成TTS时，`tts_v2`端点会利用这些信息。此外，系统还维护一个全局的`config.json`文件，其中的`tts_models`字段定义了可用的TTS后端服务，包括其显示名称和对应的API端点。`tts_v2`端点会根据请求中的`tts_model`参数或`config.json`中的`default_tts_model`设置来决定使用哪个后端。

**Section sources**
- [serverV2.py](file://serverV2.py#L212-L224)
- [serverV2.py](file://serverV2.py#L1735-L1747)
- [serverV2.py](file://serverV2.py#L1710-L1713)

## 文本预处理：替换规则应用
在将文本发送给TTS微服务之前，系统会执行一个关键的预处理步骤，即应用替换规则。这一功能由`apply_replacement_rules`函数实现。该函数会根据`novel_name`参数，定位到对应小说项目目录下的`replace_dict.json`文件。如果该文件存在，函数会加载其中的规则列表。规则会按照`original_word`的长度从长到短进行排序，以避免短词替换干扰长词。随后，函数会遍历所有规则，使用正则表达式对`tts_text`进行全局替换。此过程确保了在生成语音前，文本中的特定词汇（如人名、地名）能被预先修正。

**Section sources**
- [serverV2.py](file://serverV2.py#L521-L559)
- [serverV2.py](file://serverV2.py#L1748)

## TTS生成重试与质量保障机制
为了提高生成成功率并保障音频质量，系统实现了多层次的重试和质量检查机制。首先，`TTS_GENERATION_MAX_RETRIES`常量（默认值为5）定义了后端内部的最大重试次数。在`/api/tts_v2`端点的实现中，有一个`for`循环，会根据此常量进行重试。每次重试前，系统会短暂休眠2秒。其次，系统会对接收到的音频数据进行质量分析。它会检查音频结尾`TTS_TAIL_ANALYSIS_DURATION_MS`毫秒（默认30ms）内的能量（`dBFS`）。如果能量高于`TTS_TAIL_ENERGY_THRESHOLD_DBFS`（默认-40dBFS），则认为音频可能被截断。系统会记录所有重试中“最不戛然而止”的音频，并在所有重试失败后保存这个最佳结果，以最大限度地保证可用性。

**Section sources**
- [serverV2.py](file://serverV2.py#L53-L55)
- [serverV2.py](file://serverV2.py#L1764-L1842)

## TTS后端选择与请求构造
`/api/tts_v2`端点能够根据`inference_mode`和`tts_model`参数选择不同的TTS后端。其选择逻辑如下：优先使用请求中指定的`tts_model`，若该模型在`config.json`中存在且配置有效，则使用它；否则，使用`config.json`中`general`部分定义的`default_tts_model`。一旦确定了目标模型，系统会从`config.json`中获取其`endpoint`。随后，系统会构造一个符合微服务要求的请求体（`payload`），该请求体不仅包含`prompt_audio`和`prompt_text`，还包含了`inference_mode`和`instruct_text`等模式信息，然后通过`requests.post`发送到指定的微服务端点。

**Section sources**
- [serverV2.py](file://serverV2.py#L1735-L1757)

## 音频文件保存与日志记录
当TTS微服务成功返回音频数据后，系统会将其保存到本地。生成的WAV文件遵循特定的命名和存储规则。文件的存储路径为`output/{novel_name}/wavs/{chapter_name}/`。文件名由`row_index`（4位数字填充）、`speaker`和`timbre`三部分组成，格式为`{row_index:04d}-{safe_speaker}-{safe_timbre}.wav`。在保存文件前，路径中的所有目录都会被自动创建。整个生成过程中的关键步骤，如请求发送、重试、质量检查和文件保存，都会通过`logger`模块记录到日志中，便于问题追踪和调试。

**Section sources**
- [serverV2.py](file://serverV2.py#L1844-L1855)